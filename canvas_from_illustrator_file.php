<?php
//************************
//canvas_from_illustrator_file.php
//
//Jon Hellebuyck
//mode13.com
//
//Change log:
//3/15/2016 - Initial file finalized
//
//Generate HTML5 Canvas Javascript drawing commands based on the contents of the passed Adobe Illustrator file (currently works for the
//Illustrator 7 format).  This function will issue vector drawing commands (lines and bezier curves) for each point in the file using the correct 
//colors and line widths.
//
//WARNING - The y-coordinate system of Illustrator is the opposite of HTML5 canvas (inverted), so you will have to perform a negative scale on the y-axis
//			in order for your output to look correct.  This function does not perform this transformation.
//*************************


//canvasDrawCommandsFromIllustratorFile
//
//Reads the passed Illustrator file and echoes Javascript drawing commands that approximate the shapes in the file.  This includes
//stroke color and width as well as fill color.  The Javascript generated by this function only handles curve drawing (everything
//between beginPath and closePath) and color states.  It doesn't do things like change the global alpha or perform transformations (though 
//proportional distances between muliple paths in the same file are preserved).
//
//Parameters:
//$filePath - the path to the Adobe Illustrator file to be read
//$canvasContextName - 	the name of the variable in your Javascript code that represents the canvas drawing context (not the element).  This name
//						will be prepended to the canvas function calls this function generates.  If you pass a variable name that doesn't 
//						exist or doesn't point to a	canvas context, your Javascript debugger will show errors when running the code that is produced by this function.
function canvasDrawCommandsFromIllustratorFile($filePath, $canvasContextName)
{
	//variables
	$lineElements;	//each individual value on a line in the file, typically separated by spaces.
	$ignoreLine;	//if TRUE, the line contains something that isn't valueable for this routine, so don't process it.
	$javascriptOutput;	//the final Javascript code string that is echoed.
	
	//read the passed file
	$fileContents = file($filePath);
	
	//if the file could be read...
	if($fileContents != FALSE)
	{
		//...go through each line of the file and process it.
		foreach($fileContents as $fileLine)
		{
			//trim the newline character
			$fileLine = trim($fileLine);
			
			//see if this is a line thst should be ignored
			$ignoreLine = FALSE;
			
			//if the line begins with "%" (comment) ignore it
			if(eregi("^%", $fileLine) == TRUE)
			{
				$ignoreLine = TRUE;
			}
			//if the line begins with "Adobe_", which are values that won't be needed for this function, ignore it
			else if(eregi("^Adobe_", $fileLine) == TRUE)
			{
				$ignoreLine = TRUE;
			}
			
			if($ignoreLine == FALSE)
			{
				//line ending in " w" - the line thickness should be changed
				if(eregi(" w$", $fileLine) == TRUE)
				{
					$lineElements = explode(" ", $fileLine);
					$javascriptOutput = $canvasContextName . ".lineWidth = " . $lineElements[0] / 0.24 . ";";
				}
				//line ending in " XA" (case sensitive) - the stroke color should be changed
				else if(ereg(" XA$", $fileLine) == TRUE)
				{
					$lineElements = explode(" ", $fileLine);
					$hexColor = rgbToHex($lineElements[0],$lineElements[1],$lineElements[2]);
					$javascriptOutput = $canvasContextName . ".strokeStyle = \"" . $hexColor . "\";";
				}
				//line ending in " Xa" (case sensitive) - the fill color should be changed
				else if(ereg(" Xa$", $fileLine) == TRUE)
				{
					$lineElements = explode(" ", $fileLine);
					$hexColor = rgbToHex($lineElements[0],$lineElements[1],$lineElements[2]);
					$javascriptOutput = $canvasContextName . ".fillStyle = \"" . $hexColor . "\";";
				}
				//line ending in " m" - move to the specified coordinates
				else if(eregi(" m$", $fileLine) == TRUE)
				{
					$lineElements = explode(" ", $fileLine);
					$javascriptOutput = $canvasContextName . ".beginPath();\n" . $canvasContextName . ".moveTo(" . $lineElements[0] . ", " . $lineElements[1] . ");";
				}
				//line ending in " l" - line to specified coordinates
				else if(ereg(" l$", $fileLine) == TRUE)
				{
					$lineElements = explode(" ", $fileLine);
					$javascriptOutput = $canvasContextName . ".lineTo(" . $lineElements[0] . ", " . $lineElements[1] . ");";
				}
				//line ending in " c" - curve to specified coordinates with specified control points
				else if(ereg(" c$", $fileLine) == TRUE)
				{
					$lineElements = explode(" ", $fileLine);
					$javascriptOutput = $canvasContextName . ".bezierCurveTo(" . $lineElements[0] . ", " . $lineElements[1] . ", " . $lineElements[2] . ", " . $lineElements[3] . ", " . $lineElements[4] . ", " . $lineElements[5] . ");";
				}
				//line with only a "b" - close the curve and fill
				else if(ereg("^b$", $fileLine) == TRUE)
				{
					$javascriptOutput = $canvasContextName . ".stroke();\n" . $canvasContextName . ".fill();\n" . $canvasContextName . ".closePath();";
				}
				//line with only an "S" - stroke the curve (no fill)
				else if(eregi("^s$", $fileLine) == TRUE)
				{
					$javascriptOutput = $canvasContextName . ".stroke();\n" . $canvasContextName . ".closePath();";
				}
				//line with only an "f" - fill the curve (no stroke)
				else if(eregi("^f$", $fileLine) == TRUE)
				{
					$javascriptOutput = $canvasContextName . ".fill();\n" . $canvasContextName . ".closePath();";
				}
				else
				{
					$javascriptOutput = "";
				}
			}
			
			//write the Javascript line
			if($javascriptOutput != "")
			{
				//for debugging - echo the raw lines from the Illustrator file
				//echo "//" . $fileLine, "\n";
				echo $javascriptOutput, "\n";
			}
		}
	}	
}

//rgbToHex
//
//Convert individual red, green, and blue values to a single hexidecimal string preceeded by a pound sign.  The color component values
//passed to this function must be in the range 0.0 - 1.0, and will be clamped to that range if they are not.
//
//Parameters:
//$red - the red component of the color to be converted (0.0 - 1.0)
//$green - the green component of the color to be converted (0.0 - 1.0)
//$blue - the blue component of the color to be converted (0.0 - 1.0)
function rgbToHex($red, $green, $blue)
{
	//variables
	$hexColorString;	//full hex color string that will be returned
	//individual color components
	$redHex;
	$greenHex;
	$blueHex;
	
	//compute the red hexidecimal component
	$red255 = clamp($red, 0.0, 1.0) * 255;
	if($red255 < 16)
	{
		$redHex = "0" . dechex($red255);
	}
	else
	{
		$redHex = dechex($red255);
	}
	
	//green
	$green255 = clamp($green, 0.0, 1.0) * 255;
	if($green255 < 16)
	{
		$greenHex = "0" . dechex($green255);
	}
	else
	{
		$greenHex = dechex($green255);
	}
	
	//blue
	$blue255 = clamp($blue, 0.0, 1.0) * 255;
	if($blue255 < 16)
	{
		$blueHex = "0" . dechex($blue255);
	}
	else
	{
		$blueHex = dechex($blue255);
	}
	
	//concatentate the individual color components into one string
	$hexColorString = "#" . $redHex . $greenHex . $blueHex;
	
	return $hexColorString;	
}

//clamp
//
//Ensures that the passed $value is within the passed range of $minValue and $maxValue.  If $value is too high, 
//$maxValue is returned.  If $value is too low, $minValue is returned.  If $value is within the passed range
//then $value is returned.
function clamp($value, $minValue, $maxValue)
{
	if($value > $maxValue)
	{
		return $maxValue;
	}
	else if($value < $minValue)
	{
		return $minValue;
	}
	else
	{
		return $value;
	}
}
?>
